# -*- coding: utf-8 -*-
"""B1+B2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10w6xAzCZGkpCrbTGCkoCPpfODfT9Y2V9
"""

from google.colab import drive
drive.mount('/content/drive')

import scipy.io.wavfile as wavfile
import matplotlib.pyplot as plt
import numpy as np
from scipy.signal import resample
import warnings
warnings.filterwarnings("ignore", category=wavfile.WavFileWarning)

# Replace 'your_file_path.wav' with the actual path to your .wav file
file_path = "/content/drive/MyDrive/bme_252/Audio-08-05-2023-12-35-14.wav"

# Read the .wav file
sample_rate, audio_data = wavfile.read(file_path)

print("SAMPLE RATE: ", sample_rate)

# Downsample the audio to 16kHz
target_sample_rate = 16000
downsample_factor = sample_rate / target_sample_rate
audio_data = resample(audio_data, int(len(audio_data) / downsample_factor))

# Create a time axis based on the new sample rate and the number of samples
time = np.arange(0, len(audio_data)) / target_sample_rate

# Plot the downsampled waveform
plt.figure(figsize=(10, 4))
plt.plot(time, audio_data, linewidth=0.5)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title('Downsampled Waveform (16kHz) of the .wav file')
plt.grid(True)
plt.show()

# Calculate the desired duration of each chunk in milliseconds
chunk_duration_ms = 20

# Convert chunk duration from milliseconds to samples
chunk_duration_samples = int(16000 * chunk_duration_ms / 1000)

# Divide the audio data into chunks
audio_chunks = [audio_data[i:i + chunk_duration_samples] for i in range(0, len(audio_data), chunk_duration_samples)]

# Create a time axis based on the new sample rate and the number of samples for each chunk
time = np.arange(0, chunk_duration_samples) / sample_rate

# Plot the first chunk as an example
plt.figure(figsize=(10, 4))
plt.plot(time, audio_chunks[0], linewidth=0.5)
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title(f'Chunk 1 - {chunk_duration_ms} ms')
plt.grid(True)
plt.show()

import scipy.io.wavfile as wavfile
import matplotlib.pyplot as plt
import numpy as np
from scipy.signal import butter, lfilter, resample

sample_rate = 16000

# Parameters for the filter bank
center_frequencies = np.arange(80, 250, 10)
num_filters = len(center_frequencies)
bandwidth_hz = 10  # Adjust this based on your needs for a resonant, metallic effect
filter_order = 4

# Assuming audio_chunks is a list of audio chunks, and each chunk has a length of chunk_duration_samples
chunk_duration_samples = len(audio_chunks[0])

# Design the band-pass filters and apply to each chunk
filtered_audio_chunks = []
for chunk in audio_chunks:
    filtered_chunk = np.zeros_like(chunk)
    for freq in center_frequencies:
        low_cutoff_freq = freq - bandwidth_hz / 2
        high_cutoff_freq = freq + bandwidth_hz / 2
        b, a = butter(filter_order, [low_cutoff_freq / (0.5 * sample_rate), high_cutoff_freq / (0.5 * sample_rate)], btype='band')
        filtered_chunk += lfilter(b, a, chunk)
    filtered_chunk /= len(center_frequencies)
    filtered_audio_chunks.append(filtered_chunk)

# Create a time axis based on the new sample rate and the number of samples for each chunk
time = np.arange(0, chunk_duration_samples) / sample_rate

# Plot all 5 filters for the first chunk
plt.figure(figsize=(10, 4))
for i in range(num_filters):
    plt.plot(time, filtered_audio_chunks[i], linewidth=0.5, label=f"Filter {i+1} - {center_frequencies[i]} Hz")
plt.xlabel('Time (s)')
plt.ylabel('Amplitude')
plt.title(f'Filtered Chunk 1')
plt.grid(True)
plt.legend()
plt.show()

print("NUMBER OF AUDIO CHUNKS: ", len(audio_chunks))

import scipy.io.wavfile as wavfile

# Function to synthesize the sine-waves for each band
def synthesize_sine_waves(filtered_audio_chunks):
    synth_audio_chunks = []
    for chunk in filtered_audio_chunks:
        synth_chunk = np.zeros_like(chunk)
        for i, freq in enumerate(center_frequencies):
            rms = np.sqrt(np.mean(chunk**2))  # Calculate RMS for the current band
            synth_chunk += rms * np.sin(2 * np.pi * freq * np.arange(len(chunk)) / 16000)
        synth_audio_chunks.append(synth_chunk)
    return synth_audio_chunks

# Synthesize sine-waves for each band and each chunk
synthesized_audio_chunks = synthesize_sine_waves(filtered_audio_chunks)

# Concatenate the synthesized chunks to get the final output
final_output = np.concatenate(synthesized_audio_chunks)

# Save the final synthesized audio as a new WAV file in Google Drive
output_file_path = "/content/drive/MyDrive/bme_252/output_synthesized_au11dio.wav"
wavfile.write(output_file_path, sample_rate, final_output.astype(np.int16))